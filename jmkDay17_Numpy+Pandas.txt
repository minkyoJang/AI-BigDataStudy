1. 관련된 설명 보여주는거?
<까먹으면 안 되는 2가지>
- np.lookfor
	> np.lookfor('shape')
	> np.lookfor('create array')
	> np.lookfor('* array')
- np.info

2. array 몇 차인이 어떻게 아는가?
- []괄호의 갯수

3. 여러개를 하나로 줄이는것?
- 리듀스

4. 모양 바꾸려면 무엇을 이용하나?
- reshape ()
- b=a.reshape(3,-1) # -1이 9로 바뀜


5. 리쉐입은 뮤터플? 이뮤터플?
- 뮤터플

#예시
-  a=np.arange(27)
- a.shape
>> (27,)
- a.reshape(3,9)
#얘는 1차. 콤마는 왜 표현을 했을까? 튜플로 표현했기에 하나짜리는 저렇게 표현한거에요. 
- b=a.reshape(3.9).copy()
	>> 이렇게 써야함*****
6. 기본적으로 카피는 딥? 스왈로?
- 딥

7. reshape하면 원래 값도 바뀔수 있기에 어떻게 써야하나?
- 카피 써야한다
- b=a.reshape(3.9).copy()

8. Reshape, Resize 차이?
- Resize는 뮤터블 자기자신 변경
- Reshape는 재할당이며, 실수 막기 위해 copy같이

9. Resize 크기 맞춘다?
- 안 맞춰도 실행되긴한다.
- 부족하면? 0으로 패딩하고
- 넘치면? 잘라서 나온다. 
a=np.arange(27)
- a.resize((3,5))

10. Resize 네거티브 허용?
- 허용 안한다. 

b=np.arange(5)
b
	>>array([0, 1, 2, 3, 4])

c=np.arange(5,10)
c
	>>array([5, 6, 7, 8, 9])

- np.stack((b,c))
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])

- np.stack((b,c),1)
array([[0, 5],
       [1, 6],
       [2, 7],
       [3, 8],
       [4, 9]])

-np.hstack((b,c))
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

- np.vstack((b,c))
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])


11. Reshape 네거티브 허용?
- 허용
- b=a.reshape(-1,-1)
- b=a.reshape(3,-100)

12. split?
- 기준에 의해 쪼기는거

13. split 결과값 어떤 형태로 보내나요?
- 리스트

14. split 3종류?
- split, vsplit, hsplit

15. 파이썬 접근 방식 2개?
- 펑션 방식/ 메소드 방식

16. 차원 변화 (1>2)
- reshape
- a=np.arange(6)
-a
	>> array([0, 1, 2, 3, 4, 5])
- a.reshape(6,1)
array([[0],
       [1],
       [2],
       [3],
       [4],
       [5]])

이런거 말고, 양 옆에 [] 더 추가하는 식으로 하고 싶으면?





16. np.split(a,(1,2)) 어떻게 잘린거?
- 세번 잘림. 0~1까지, 1~2까지, 2~3까지

17. split 튜플 형태로 자를수 있나?
- 응

18. np.split(a,(2,2))?
-0~2사이까지, 
[array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8],
        [ 9, 10, 11, 12, 13, 14, 15, 16, 17]]),
 array([], shape=(0, 9), dtype=int32),
 array([[18, 19, 20, 21, 22, 23, 24, 25, 26]])]

19. 오잉 np.split(a,(5,5),axis=1) 
[array([[ 0,  1,  2,  3,  4],
        [ 9, 10, 11, 12, 13],
        [18, 19, 20, 21, 22]]),
 array([], shape=(3, 0), dtype=int32),
 array([[ 5,  6,  7,  8],
        [14, 15, 16, 17],
        [23, 24, 25, 26]])]


20. split 액시스 0이?1이? 
- 브이스플릿, 액시스1한게 브이스플릿

21. stack 종류?
- hstack, vstack
-np.hstack((b,c))
- np.stack((b,c),1)


22. 언더바 삼총사(
- np.r_[b,c] 
- np.c_[b,c] 
- np.s_[b,c] //슬라이스

23. 위의 세개는 뭐의 단축?-
- stack 단축표현들

24. 컬럼 붙일때 사용?
- np.column_stack([b,c])
array([[0, 5],
       [1, 6],
       [2, 7],
       [3, 8],
       [4, 9]])

-------------
a=np.arange(6)
--------------
@@@@@
newaxis
a[:, np.newaxis]

a[:,:, np.newaxis]

25. shape을 매트릭스의 모양을 자유자재로 바꾸는데 쓰는거
1)- []
a[:, np.newaxis]
a[:,:, np.newaxis]

-----------예시--------------
-a=np.arange(6)
-a
>>array([0, 1, 2, 3, 4, 5])
-a[:,np.newaxis]
>>array([[0],
       [1],
       [2],
       [3],
       [4],
       [5]])

이거 어려워서 쓰는게 expand_dims()
np.expand_dims(a,1)
array([[0],
       [1],
       [2],
       [3],
       [4],
       [5]])
----------------------------------------
2)- expand_dims
- np.expand_dims(a,1)
-array([[0],
       [1],
       [2],
       [3],
       [4],
       [5]])

26. expand_dims(,)는 차원을 몇 단계 더 올릴 수있나?
- 1개

27.  1차원<> 3차원 가능하나? 
- 응 이럴떄 사용하는게
- swapaxes((,)) & moveaxies((,))
array([[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8]],

       [[ 9, 10, 11],
        [12, 13, 14],
        [15, 16, 17]],

       [[18, 19, 20],
        [21, 22, 23],
        [24, 25, 26]]])


a=np.arange(27).reshape(3,3,3)


28. 축끼리 값 변경?
- swapaxes((,))
- np.swapaxes(a,0,2)
array([[[ 0,  9, 18],
        [ 3, 12, 21],
        [ 6, 15, 24]],

       [[ 1, 10, 19],
        [ 4, 13, 22],
        [ 7, 16, 25]],

       [[ 2, 11, 20],
        [ 5, 14, 23],
        [ 8, 17, 26]]])


29. 축 이동?
- moveaxies((,))
- np.moveaxis(a,0,2)
array([[[ 0,  9, 18],
        [ 1, 10, 19],
        [ 2, 11, 20]],

       [[ 3, 12, 21],
        [ 4, 13, 22],
        [ 5, 14, 23]],

       [[ 6, 15, 24],
        [ 7, 16, 25],
        [ 8, 17, 26]]])

30. 스트럭쳐드 어레이?

31. 스트럭쳐드 어레이랑 유사한거?
- 네임드  튜플
from collections import namedtuple
namedtuple
Address=namedtuple('Address',('name','age','weight'))
al=Address('Rex', 27,81.0)

32. 파이썬 클래스 정의?
- 정의 안 해도 된다
- 메타클래스 쓰면 클래스 정의 안해도 클래스 처럼 쓸 수 있어
- 네임드 튜플도 유사해.
- 튜플에 있는 인덱스하고 카운트까지 지원해
- 따라서 얘는 튜플이라서 어떻게 쓸 수 있따?
    - al[0]
    - al[1] 
    - 즉, 이름 및 인덱스로도 사용할 수 있음


33. 인덱스로 접근 가능함?
- 응 al[0]
'Rex'

34. 키로 접근 가능함?
- 아니 보통 인덱스로 접근하면, '키'로는 접근이 안돼. 생성은 되긴함. al['name']
타입에러

35.  네임드 튜플에서 안 된거?
- 키로 네임 접근하니까 안되었음. 

36. 넌파이는?
- 그러나 넌파이 스트럭쳐드는 키로도 접근이 가능함
    - 이 방식은 편히 '딕셔너리'방식이라고 할게요. 그럼 어떤 데이터만 가져오냐면 
        - 즉, 행으로도, 열로도 가능해요

37. - 인덱스 치면 ? 
- 로우 가져온다. 튜플/딕셔너리 방식으로하면 컬럼 데이터를 가져온다

38. 스트럭쳐드는 어디에ㅓㅅ 돌아?
- 메모리

39. 엑셀은 어디에서 돌아?
- 디스크, 가상 메모리. 좀 느려

40. 설명
#### 데이터 프레임은 판다스의 기본적인 자료형태
- 판다스도 넌파이 기반
- tpe(tips) 쳐봐
- 위의 결과는 스트럭쳐드 어레이 사용한거야
    - 세로 뽑을떄 부슨 방식 으로 뽑아? 
        - 아까 키로 뽑았잖아

#### 어트리뷰트는 아까 안됬죠 넌파이는
- 근데 판다스는 스트럭쳐 플러스 알파가 들어왔어
- 즉 점으로 접근 가능
- .어르티 뷰트 방식으로도 접근 가능.
- 네임드 튜플의 성질을 이용했는데 확장을 시킴. 

####  사이즈 왜 될까
- 얘는 넌파이 기반
- 넌파이에서 중요한 속성(shape, dtype)
    - shppe에서 두개 곱하면 사이즈 알 수 있땠됴. 
        - tips.size하면 사이즈 메소드를 부르는 거에요. 
        - 얘는 '넌파이' 기반이니까
        - 그럼 넌파이를 알아야 저게 왜 안 되는지 알 수 있죠
- 그럼 우린 무슨 방식으로 부르면 된다?
    - 키방식.
    - 점으로 불렀더니 '키'가 넌파이에 있는 가장 기본적인 메소드 이름고 ㅏ동일하기 때문에 문제가 생겼어. 원하는 컬럼값 안불러와
- 그럼 스트럭쳐드니까 키 방식으로 불러봅시다.
    - 문제 있어. 
    - 간혹 공백 있으면 안 불러 올 수 있어. 
    - 공백있으면 무슨 방식으로 부른다? 키 방식. 왜냐하면 스트럭쳐드 어레이니까.
- 그럼 가로 한 줄씩 뽑아내나?
    - 스트럭쳐드가 가능했잖아. 그래서 여기서도 가능해
    - 근데 같은 방식으로 뽑을때 얘도 문제가 있어. 
- 스트럭쳐드의 문제점
 
### 아까 숫자로 인덱스 시켰죠.
- 그러면 얘가 숫자인지 문자인지 모르겠죠. 넌파이에서는 name이 문자라서 얘로 뽑으면 세로로 했고, 인덱스로는 가로로 뽑앗는데
- 판다스에서는 이름도 숫자로 표현되어서 위와 같은 방식으로 ㄹ바로 쓸 수 없어
- 그래서 판다스가 어떤 고민을 했냐
    - 
### 아까 숫자로 인덱스 시켰죠.
- 그러면 얘가 숫자인지 문자인지 모르겠죠. 넌파이에서는 name이 문자라서 얘로 뽑으면 세로로 했고, 인덱스로는 가로로 뽑앗는데
- 판다스에서는 이름도 숫자로 표현되어서 위와 같은 방식으로 ㄹ바로 쓸 수 없어
- 그래서 판다스가 어떤 고민을 했냐
    - 뭘 하나 더 붙이고 tips.loc[] 저렇게 스트럭쳐드에서 행을 뽑아왔어요
  #### 이게 정형데이터
- 가장 밑에 숨어있는 개념이 스트럭쳐드 어레이!!

#### 나름교수님정리) 이름있고 이름 위에 데ㅐ이터의 타입이 있죠
- 키 방식으로 사용하면 열이 추출되고, 
- 인덱스 방식으로는 로우가 추출
- 그러면 인덱스는 슬라이싱 가능? 네
    - 그럼 부분적인 데이터만 가져올 수 있을거에요.
#### 넌파이의 '스트럭쳐드 어레이'



41. 판다스에서 맨위에 있는거?
    - 컬럼 및 헤더
42. 판다스에서 맨 왼쪽에 있는거?
    - 인덱스
43. 판다스에서 2차원 데이터 구조
    - 데이터 프레임

44. 데이터 뽑는방식2개
-1. 키로 뽑는방식
-2. 어트리뷰트로 뽑는방식
    - 넌파이는 없지만 판다스에는 있어

45. 
    - 어트리뷰트에 문제가 사실 있어. 저 size 같이 기본 메소드랑 동일 이름이거나 공백 있으면 사용하지 못했거든
    - 근데 왜 지원하게 되었나? 편해서
    - 키 방식으로 쓰면 4글자 써야하고 어트리뷰트는 점 하나만 쓰면 되니까........ 그래서 어트리뷰트 지원하는데 골치아픈 이슈 생긴대
    - 나중에 나올건데 



46. 판다스에서 팬시 인덱싱가능?
- 응 넌파이 기반이니까
-tips[['day','time']]

47.값을 1개 뽑을떄랑 2개이상 뽑을떄 왜 그림이 다르죠?
- 타입을 해봐
- type(tips.day)
>> pandas.core.series.Series

48 시리즈?
	-  왼쪽에 있는 숫자들
49. tips.tip.values 
    - 어찌아느냐? 점 벨류즈(r
array([ 1.01,  1.66,  3.5 ,  3.31,  3.61,  4.71,  2.  ,  3.12,  1.96,
        3.23,  1.71,  5.  ,  1.57,  3.  ,  3.02,  3.92,  1.67,  3.71,
        3.5 ,  3.35,  4.08,  2.75,  2.23,  7.58,  3.18,  2.34,  2.  ,
        2.  ,  4.3 ,  3.  ,  1.45,  2.5 ,  3.  ,  2.45,  3.27,  3.6 ,
        2.  ,  3.07,  2.31,  5.  , 

50. 브로드 캐스팅 되나?
- 응
- tips.tip+5

51. 리덕션 되나?
- 응. 여러개 한번에 표시하는 sum 되더라
-tips.tip.sum()
>>731.5799999999999

52. 값은 ?
- 넌파이 어레이 포멧

53.가로/세로~ '시리즈'
- 우리가 배운 어레이에서는 방향 없어. 시리즈는 가로든 세로든 중요하지 않아.
- 즉 방향이 없다는거야. 
    
 
54. 행가져오는 방식 2가지
- loc, iloc
>> tips.iloc[3]
>> tips.loc[3]

55. 쟤네 슬라이싱 가능?
- 가능

56. loc & iloc 차이
- tips.loc[3:6] 6이포함되고, tips.iloc[3:6]하니까 6이 포함 안돼
- loc는 이름 기반. 끝에있는거 포함
- iloc는 인덱스 기반. 끝에 있는거 포함 안함

57. , 조건, 마스킹, 팬시인덱싱, 컴마 다 가능하니까
- tips.loc[3:6,['day','smoker']]
- tips.loc[3,'day']

58. 행 가져올때 순서 바꿔도 되니?
- 응

59. #### 컴마 인덱싱, 컴마 슬라이싱 지원
- iloc는 파이썬과 동일
-tips.iloc[3:6:]

60. ㄸ애땡떙 지원?
- 이건 안해 iloc.

61 열 뽑아오는 방식 3개 기본//어키팬인
- 어트리뷰트 방식: 편하게 쓰려고 지원하나 사이즈/공백 있을떄 안 되고 있어요
- 키 방식: 가장 기본적이야. 넌파이 스트럭쳐 그대로 가져오니
- 팬시 인덱싱
    - 특징: 데이터 프레임으로 가져와@
    - tips[['tip']]

62. 열 뽑는 3개중 속도 빠른거? 
- 키 방식. 넌파이 그대로 가져오니까

63.하나만 가져오는 방식 3개
- tips.loc[3,'tip']
- iat으로 인덱스 방식
    - tips.iat[3,5]
- at으로 이름 방식
    -tips.at[3,'time']

64. 정리
- 특정 열만 뽑는거 3개 //어/키/팬인
- 행 뽑는거 2개 //loc iloc
- 특정 값 4개// loc, iloc, iat, at

65. 넌파이의 역할?
- 벡터 기반으로 데이터 처리하는 라이브러리

66. 판다스 역할
- 판다스는 넌파이 기반으로 eda (exp..)하고 데이터 전처리 하는 애

67. eda?
- Exploratory Data Analysis

68. eda 기본 역할?
- 미싱 데이터 찾는다. 
- 탐색적 데이터 분석
- 기술통계 편하게 하려고 하는 거
- 기초 분석 하는 도구
- 데이터 먼징 렁글링 멍징 하는 도구

69. 데이터 랭글링?
- 데이터를 불러오고 그걸 합치고 간단한 전처리하고 기초분석까지 하는 것
 - ETL과 유사해요. 

70. ETL과 랭글링 차이
- etl는 개발자, 랭글링은 분석가 차이

71. 버전관리

72. 워터마크
- %watermark -a'문근영' -d -p numpy,pandas
- -a: 저장
- -d: 날짜
- -p : 

73. 그래프
- %matplotlib inline
- pd.plotting.scatter_matrix(data)

74. missing data 처리방식
    - 1.삭제
    - 2.특별한 수로 채운다
    - 3.인터폴레이트

75. <1>datainfo에서 봐야하는거
- range index
- missing data
- object
- dtypes
- 메모리 사용률

76. 판다스에서 문자열?
- 문자열은 오브젝트로 표현돼


77.<2>data.describe()
- 컬럼에 대한 통계 보여줌

78. size와 count 차이?
- size: 미싱 데이터 포함
- count: 미싱 데이터 불 포함 갯수


79. data.describe()하면 카운트, 민, 표준분포, 등이 나와 이떄 중요한 2개념?
- 큰수의 법칙, 중심 극한 정리

80. 외도, 첨도?
- 외도는 얼마나 쳐우쳤는지, 첨도는 뾰족한지
- data.skew()
- data.kurt()
- data.kurtosis()

81. data.describe로 뭐 알 수 있어?
- 정규성과 박스플롯

82. 박스플롯 그리는법
- data.boxplot()
----점심-----
83. describe로 뭐한다?
- 데이터의 분포를 본다.
- data.describe(include='object')
- data.describe(include='all')
	-float64, number처럼 원하는것만 include해서 할 수도 있다.


84.info>describe 다음에 할 것?
- seaborn.
- import seaborn as sns
	1. s는 statistical 통계쪽에 대한 멘트임. 
	2. 이뻐
		- info>describe하면 숫자만 봐서 안 예뻐

85. 분석 순서
- info
- describe(boxplot그림)
- pairplot에서 그림, 

86. 카테고리?
- 판다스에서 지원하는 성별 같은 몇 없는 문자열/숫자열

87. describe에서 볼 수 있는것?
- 숫자 데이터

88. describe에서 더 보고 싶으면?
- include

89. 분석에서 필요한것?
-프로그래밍 하나, 통계 수학 하나, 도메인 지식

90. 어그리게이션 분석?
- 그룹으로 묶어서 날짜로 묶어서 최소 최대 보기 및 성별로 평균/합계 등 보기 할때 사용
- 예시) tips.groupby('sex').mean()


# 2개만 보고싶으면?
- 팬스 인덱싱
- tips.groupby(['sex','day'])['total_bill','tip'].mean()

# 어떤 상황에서 팁이 많은가 볼 수 있다
- tips.groupby(['sex','day','time'])['total_bill','tip'].mean()

91. 어그리게이션 어떤거 주의하고 어떤게 좋아?
- 개별적인거 확대할 수 있어 주의하고
- 경향을 보여줄 수 있어서 사용

92. 그래프 그리려면?
- .plot 하면 그래프 그리는거 나와요. 탭키 눌러봐요

93. 판다스 분석에서 할수 있는거 2가지
1. 기초통계분석을 위해 데이터 불러오기
2. 어그리게이션분석으로 그림 그리기

94. 공공데이터 불러올떄 옵션
- olds =pd.read_csv("C:\Python\download/ttt.csv",engine='python',encoding='cp949')
- olds

95. 연변
- 필요 없어
- 인덱스 쓰니까
    -1. 연번을 인덱스로 만드는 방법
    -2. 연변을 삭제하는 방법
- 인덱스: 맨 왼쪽에 있고 0부터 시작
    - index 컬럼이있는데 이 옵션을 줄게요
        - olds =pd.read_csv("C:\Python\download/ttt.csv",engine='python',encoding='cp949', index_col='연번')

96. 원본 저장
- olds_raw=old.copy()
---기본 인덱스 관련된 3가지----
1. 가져올때 정하는 방법
2. 가져와서 setindex
3. reset인덱스해서 기존의것 초기화시키기

------------------------------------
컬럼 지우는 방법
1. drop으로 컬럼 지움
- drop은 판다스에서 모든거 지울떄 사용
- olds.drop(columns='연변', inplace=True)
- olds.drop(label=0, inplace =True)
- old.drop(label=[2,3,4,])

97. 라벨?
- 가로든 세로든 지울 수 있게끔 할려고(axis=0, axis=1) 
- 가능한 중복된 의미가 없는게 좋은 데이터 소스니까요. 
- olds.drop(labels='소재지', axis=1) //소재지 지워

98. 이름 변경
- rename
- olds.rename({'소재지':'주소'})
- olds.rename({'소재지':'주소'}, inplace=True)
- olds.rename({'소재지':'주소'}, axis=1)
- tips.rename({'size':'size_'}, axis=1) //된다
- 어트리뷰트 방식으로는 안 됩니다.

99. 원본으로 돌아가는 방법@@


100. 해보고 잘 되면 그때 inplace=True옵션
- 재할당 하지 않고 반영

101. 파이썬을 날짜를 관리하는 패키지가 3개 있어
1. 타임 패키지
	- 속도 측정
2. 칼린더 패키지
	- 시간 날짜에 대한것 
3. 데이트 타임 패키지
	- 엄청난 단점 있엇 파이ㅏ썬 하는 사람은 잘 안쓰고 데이트 타임 유티이라는 써드 파티 많이 씀
	- import datetime
	- dir()
	
# dir했더니 거슬리는거 있음
- datetime: 시간 날짜 동시에
- date: 날짜만
- time: 시간만
- timedelta: 시각
- timezone: 표준시간대(미국등은 여러개니까)

102.dir했더니 아주 거슬리는 애가 있어
- 데이트 타임 패키지를 했는데 
- datetime: 시간 날짜 동시에
- date는 날짜만
- time은 시간만 관리
- timedelta: 시각
- timezone: 표준시간대(미국등은 여러개니까)

103. 관례상 시간 날짜 대해서 어찌 임포트해서 쓰니
- from datetime import datetime, timedelta, date, time 
- import datetime
- from datetime import datetime


104. datetime.strptime
- 문자열을 데이트 타입 객체로 관리할 수 있어요
-a=datetime.strptime('2019-07-23','%Y-%m-%d')

105. 파이썬 타입 변환 있다 없다? 
- 없다
- 그래서 인스턴스 하는 방식으로 사용합니다.

106. 넌파이는 타입 변환 있다 없다?
- 있다.
- 넌파이는 씨 기반이니까.

107. 공공 데이터 판다스에 불러 올떄 잘 안되면 해볼거
- import pandas as pd
-1. 엔진 2.인코딩 3. 잘된거 같으면 inplace True
- olds =pd.read_csv("C:\Python\download/ttt.csv",engine='python')
- olds =pd.read_csv("C:\Python\download/ttt.csv",engine='python',encoding='cp949', index_col='연번')

108. 인덱스 2개 이상 붙일 수 있는것-
- set_index, 멀티 인덱스
- 우리는 한개만 붙임
- olds.set_index('연번')

109. 판다스에서 지우는거3개
-drop
	-drop인덱스 하면 되겠죠? 근데 없어.
	- olds.drop(columns='연번', inplace=True)
- drop중에서 한번에 지울 수 있는 방법
	- olds.drop(label=[2,3,4,])
- reset_index
	- olds.reset_index(drop=True)
----------------
110. 넌파이에서 타입 변경?
- assype
- a.astype('float64')
- olds['기준일자'].astype('datetime64')

111. 타입 알고 싶을떄 디 타입 될까?
- 얘 넌파이 기반. 판다스는. 
- 넌파이 중요2개는 디타입이랑 쉐입
	- olds['기준일자'].dtype
- 쉐입 될까 안될까? 
	- olds['기준일자'].shape
- olds['기준일자'].astype('datetime64') ***


112소재지에서 '구'만 뽑아내고 싶어
- 너희 정규식 배웠음 ^-^
- 아까 오브젝트 타입이랬지 .str을 사용할 수 있음
- x=olds['소재지'].str

113. 밸류카운트
- 카테고리별로 갯수 세주는것
- tips.sex.value_counts() 
	>> 했더니 나녀 촏 앙려주네
Male      157
Female     87
Name: sex, dtype: int64

- loc는 이름으로
- tips.sex.value_counts().loc['Male']
	>> 157
- iloc는 숫자로 접근
- tips.sex.value_counts().iloc[0]
	>>157

114. 판다스에서 인덱스는?
- x축. 
- tips.sex.value_counts().plot.pie()
- 그림 그리고 싶으면 .plot
- 인덱스는 엑스축!!!점 플랏만 쓰면 돼

115. 문자열 추가기능?
- 점 str

116. 카테고리 추가기능?
- 점 cat
-t=tips.sex.cat

117. 카테고리에서 코드란?
- code: 문자열로 하면 비효율적이라서 숫자로 관리
- t.codes

118. codes를 통해 뭐가 편해져?
- 라벨링
-즉 여자0, 남자1로 관리

119. 유니크
- tips.sex.nunique()
- 카테고리 에서는 female, male 이외 쓰면 에러 발생
- 유니크하면 카테고리 이름 나오고, 
- 유니크 앞에 엔 유니크 하면 카테고리 갯수가 나와요


#인덱스슬라이싱
- loc iloc 열 다 했는데 
- 이제 복잡한거 해볼거에요.
- 기계학습해봤던 사람은 보스턴으로 리그레션했을거에요.


교수님----------
1. info
2. describe
3. head
4. tail
5. sample

#### 데이터 수집이 일정하게 되는지 여부를 체크하는거에요
- 최신 데이터하고 일년전 데이터가 다른 경우가 많아요
- 시간에 따라 축적된 양이 많을떄
--

120. 데이터 부분 보기.  데이터의 부분을 보는 명령어가 있어요
1. 앞에서 보기 
- mpg.head()
2. 뒤에서 보기
- mpg.tail()
3. 무작위로 보기
- mpg.sample()

121. 결측치 확인
- missingno
- !pip install missingno
- import missingno as mino
- dir() //처음 나왔으니 봐요

122. 그래프로 결측치 보기
- mino.matrix(mpg)
- 아까 mpg에서 미싱데이터 6개랬는데, 여기 선 6개가 horsepower있지? 그거야

123. 그래프
- mino.matrix(mpg)
- mino.dendrogram(mpg)
- mino.bar(mpg)
- mino.heatmap(mpg)

124. 히트맵
- 크면 잘 안나오는 에러 있음

125. 결측치 보기
- 그래프) 
- 식) ISNA
	- mpg.horsepower.isna()

126. 트루 펄스만 나오면 쓸 수 있느 기법?
- 마스킹
- mpg[mpg.horsepower.isna()]
   - 지금 넌값있는애만 찾을 수 있어요

127. 결측치 총값 구하기
- mpg.horsepower.isna().sum()

128. isna하고 isnull 같다?
- 네

129. 미싱데이터 처리하기 
- 1. 없애기
- 2. 가짜 데이터 넣어요. 

130. 미싱데이터 처리에서 없애는 방법
-  mpg.dropna()

131. dropna() 옵션
- mpg.dropna() 
#ShiftTab하면 보이겠지만 any가 디폴트라 그냥 하고, 나중에 반영을 위헤 inplace
- mpg.dropna(inplace=True)
- any: 하나라도
- all: 전부 다 이상하면 지워

132. dropna() 하고 반영하기 위해서?
- inplace

133. na 채우려고 하면?
- mpg.fillna(3).loc[32]

134. 콜드스타트?
- 가짜 데이터 만들기
- 데이터가 적어서 알고리즘 잘 적용 안되는 경우

135. 인터폴레이트
- 도메인 따라 다 달라. 다 하기에 시간 많이 걸려
- 싸이 파이에 많아
- from scipy import interpolate

# mpg.fillna(3).loc[32]
<- 이거 결측치 할떄 채워넣었음

136. 가로 세로 값 변경
- mpg.describe().T

137. 그래프 그리기
- mpg.describe().T.plot.bar()

138. 현재 컬럼들 봐볼까
-mpg.columns 
> Index(['mpg', 'cylinders', 'displacement', 'horsepower', 'weight',
       'acceleration', 'model_year', 'origin', 'name'],
      dtype='object')
- mpg.columns[:-2]
> Index(['mpg', 'cylinders', 'displacement', 'horsepower', 'weight',
       'acceleration', 'model_year'],
      dtype='object')


139. 그래프에서 'weight' 하나 빼자. 무식하게 말구
- mpg[mpg.columns[1:4]]
- mpg[mpg.columns[:-2]]

140. reg로 특정 값(weight) 이외의 것만 나오게 하기
- mpg.filter()
- mpg.filter(regex="[^weight]")

141. 열 뽑는 방식 (최소)★★★★★
1. 딕셔너리로 
2. 어트리뷰트로 뽑기
3. 팬시 인덱싱 
-  컬럼즈 (팬시 인덱싱 응용)
4. 필터 이용해서 내가 원하는 컬럼만 뽑기
- 아까 레귤러
5. select_dtype
- 데이터 타입(플롯, 오브젝트) 따라 뽑기

142. 그래프 그릴때 인덱스?
- 엑스축
- mpg.filter(regex='[^weight]').describe().T
- mpg.filter(regex='[^weight]').describe().T.plot.bar()


143. 쌓인 바플랏 그리기
- mpg.filter(regex='[^weight]').describe().T.plot.bar(stacked=True)

144. 그래프 out에 이상한 문자 나오는거 지우기?
- 끝에 세미콜런

145. 페어플랏
- 색상이 있는 그래프
- import seaborn as sns
- sns.pairplot(mpg)

146. 페어플랏 색상
- classification 가능하면 색상 진한편
- 리그레션은 색상 잘 안 칠해짐 그래서 굳이 안 해도 돼

147. 공분산
- mpg.cov()

148. 상관계수
- 1이면 관련성 높고, -1일 수록 상관성 잘 안보여
- 피어슨, 스피어만, 캔달
- mpg.corr()

149. 상관계수 관계 잘 안보이면 쓰는거?
- heatmap
- sns.heatmap(mpg.corr(), annot=True)

150. 다중 공산성**********
- 피쳐 셀렉션에 써요

151. 박스플랏 쓰는이유?
- mpg.boxplot()
- 아웃라이어 확인하기 위해서. 
- 딥러닝 뉴럴네트워크에서 시작이 노말라이제이션인데, 이걸 캐치하기 좋아

152. Outlier **************
- 1만 시간의 법칙
- 공부하세요 ^-^;
- 평균에 벗어나는 ;;
- pyod 라이브러리 기똥차
- 예측 모델의 성늦 낮춰서 보통은 없애는데, 이게 키일 수도 있어

153.  아웃라이어 체크하는 박스 플랏 퍼센트는?
- 볼 수 있어요. 안 좋은 예시인데 보여만 줄게
- mpg.describe([.005,0.5,.75])

#여기까지는 모든 데이터 동일하고 이제는 다른 접근 방식

154. Hadley Wickham
- Rstudio 만든 사람
- 최근 논문: tidy data

155. 와이드포맷
- 엄청 자주 있는 실수
- pew=pd.read_csv('C:\Python/pew.txt', delimiter='\t')

#####3
롱폼
- 멜트로 바꾼다
	- pew.melt(['religion']) 
- 그룹바이 및 디스크라이브로 의미있게 볼 수 있다
	- pew.describe()
	- pew.groupby('variable').mean()

# 이름 바꾸고 싶을떄
- pew.melt(['religion'], var_name='문', value_name='근영')
=====================


156. na값 없애기
- weather=pd.read_csv('C:\Python\weather.txt', delimiter='\t')
- weather //여기에 na 많음

157. 여러개 중에서 몇 개 컬럼만 보고파
- weather.melt(weather.columns[:4])

158. na 없애기
- weather.melt(weather.columns[:4]).dropna()

159. 컬럼명 변경
- weather.melt(weather.columns[:4]).dropna()

160. 멜트보다 조금더 예쁘게 만들어주는 (롱폼으로)
- pd.wide_to_long

161. pd.wide_to_long
- pd.wide_to_long(weather, 'd', ['id', 'year','month','element'],'')
- 공통된거 그룹화하여 보기 좋게 함

162. 타이드 데이터 생성
- 멜트, 데이터 타입, 이름 변경해서 만드는 짓
- 빌보드, 웨더 등에서
- 와이드를 롱폼으로 바꾸는 등으로 해서 하는거 알죠?
