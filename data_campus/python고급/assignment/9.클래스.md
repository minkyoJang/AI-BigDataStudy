# 9. 클래스

데이터와 기능을 함께 묶는다.

## 9.1 이름과 객체에 관한 한마디

- 객체는 독립적이다.
- 여러 이름이 같은 객체에 연결될 수 있다.

## 9.2 파이썬 스코프와 이름 공간

- *이름 공간* : 이름에서 객체로 가는 매핑
- 예
  - 내장 이름들의 집합
  - 모듈의 저역 이름들
  - 함수 호출에서의 지역 이름들
  - 객체의 어트리뷰트 집합 등
- 서로 다른 이름 공간들의 이름 간에는 아무런 관계가 없다.
- *어트리뷰트* : 점 뒤에 오는 모든 이름
- read-only 이거나 쓰기 가능할 수 있다.
  - `modname.the_answer = 42`
- 쓰기 가능한 어트리뷰트는 del문으로 삭제할 수 있다.
  - `del modname.the_answer`
- 내장 이름들의 이름공간은 영원히 지워지지 않는다
- 모듈의 전역 이름은 모듈 정의를 읽는 동안 만들어진다.
- 함수의 지역 이름 공간은 함수 호출 시 생성되고
  - 함수 복귀하거나 예외 발생 시 삭제된다
  - 재귀적 호출은 자신만의 지역 이름 공간을 갖는다.
- *스코프* : 이름 공간을 직접 접근할 수 있음
  - 가장 먼저 탐색되는 가장 내부의 스코프는 **지역 이름**
  - 둘러싸는 스코프는 **비 지역이고 비 전역 이름**
  - 마지막 직전의 스코프틑 **전역 이름**
  - 가장 외부 스코프는 내장 이름들을 포함하고 있는 **이름 공간**
- 할당은 데이터를 복사하지 않는다. 이름을 객체에 연결할 뿐
  - `del x`는 지역 스코프가 참조하는 이름 공간에서 `x`의 연결을 제거
- `global` : 전역 스코프에 있는 변수를 연결한다
- `nonlocal` : 둘러싸는 스코프에 있는 변수를 연결한다.

### 9.2.1 스코프와 이름 공간 예

```python
def scope_test():
    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)
```

```shell
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
```

## 9.3 클래스와의 첫 만남

## 9.3.1 클래스 정의 문법

```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```

- 클래스 정의에 진입할 때, 새 이름 공간이 만들어지고 지역 스코프로 사용
- 클래스 정의가 끝날 때, *클래스 객체* 가 만들어짐
  - 만들어진 이름 공간을 감싼다
- 원래의 지역 스코프가 다시 사용
  - 클래스 객체는 클래스 이름으로 지역 스코프에 연결

### 9.3.2 클래스 객체

- *어트리뷰트 참조* : `obj.name`
  - 어트리뷰트 이름 : 클래스 객체가 만들어질 때 클래스 이름 공간에 있던 모든 이름

```python
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'
```

- 값을 재할당할 수도 있다.
- `__doc__`또한 올바른 어트리뷰트

### 9.3.3 인스턴스 객체

*데이터 어트리뷰트* 와 *메서드*

### 9.3.4 메서드 객체

`x.f()` 는 `MyClass.f(x)`와 동일하다

### 9.3.5 클래스와 인스턴스 변수

인스턴스 변수 : 인스턴스별 데이터를 위함

클래스 변수 : 클래스의 모든 인스턴스에서 공유되는 어트리뷰트와 메서드

```python
class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                  # shared by all dogs
'canine'
>>> e.kind                  # shared by all dogs
'canine'
>>> d.name                  # unique to d
'Fido'
>>> e.name                  # unique to e
'Buddy'
```

muttable한 객체를 클래스 변수로 쓸 때 주의해야함! 모든 인스턴스가 공유한다.

```python
class Dog:

    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # unexpectedly shared by all dogs
['roll over', 'play dead']
```

클래스의 올바른 설계는 인스턴스 변수를 사용해야 한다.

```python
class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']
```

## 9.4 기타 주의사항들

- 데이터 어트리뷰트는 같은 이름의 메서드 어트리뷰트를 덮어쓴다.
- 데이터 어트리뷰트는 메서드를 통해서 뿐만 아니라 직접 접근이 가능
  - 은닉을 강제할 방법이 없다.
  - 조심스럽게 사용하고 명명법 잘 지키자
- 메서드는 `self`인자의 메서드 어트리뷰트를 통해 다른 메서드를 호출할 수 있다.
- `object.__class__`를 통해 객체의 클래스를 확인할 수 있다.

## 9.5 상속

- 부모 클래스가 다른 모듈에 정의되어 있을때도 상속 가능

```python
class DerivedClassName(modname.BaseClassName):
```

- 파생 클래스는 베이스 클래스의 메서드들을 재정의 할 수 있다.
- `BaseClassName.methodname(self, arguments)`
  - 부모 클래스의 메서드를 직접 호출한다.
- 상속과 함께 쓸 수 있는 내장함수
  - `isinstance()`를 통한 인스턴스 형 검사
    - `isinstance(obj, int)`는 `obj.__class__`가 int이거나 int에서 파생된 클래스일 경우에 True
  - `issubclass`를 통한 클래스 상속 검사
    - `issubclass(bool, int)`는 True이다. bool은 int의 서브 클래스.

## 9.5.1 다중 상속

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

## 9.6 비공개 변수

`__` 를 이용한 데이터 맹글링

## 9.7 잡동사니

빈 클래스 정의를 활용하여 이름 붙은 데이터 항목들을 묶는다.

```python
class Employee:
    pass

john = Employee()  # Create an empty employee record

# Fill the fields of the record
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
```

